<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/components/BurgerConstructor/BurgerConstructor.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/components/BurgerConstructor/BurgerConstructor.tsx" />
              <option name="originalContent" value="import React, {FC, SyntheticEvent, useEffect, useMemo, useRef, useCallback} from 'react';&#10;import {ConstructorElement, Button} from &quot;@ya.praktikum/react-developer-burger-ui-components&quot;;&#10;import { useDispatch, useSelector } from 'react-redux';&#10;import type { AppDispatch, RootState } from '../../services/store';&#10;import { setOrderId as setOrderIdAction, clearOrderId } from '../../services/orderIdSlice';&#10;import {BurgerCredit} from &quot;../BurgerCredit/BurgerCredit&quot;;&#10;import {CustomScrollBar} from &quot;../CustomScrollBar/CustomScrollBar&quot;;&#10;import { useDrop, useDrag } from 'react-dnd';&#10;import { addIngredient, removeIngredient, moveIngredient } from '../../services/constructorSlice';&#10;import { createOrder } from '../../services/orderSlice';&#10;&#10;import styles from './burger-constructor.module.css';&#10;&#10;const BurgerConstructor: FC = () =&gt; {&#10;    const dispatch = useDispatch&lt;AppDispatch&gt;();&#10;&#10;    const constructorState = useSelector((s: RootState) =&gt; s.burgerConstructor);&#10;&#10;    useEffect(() =&gt; {&#10;        return () =&gt; {&#10;            dispatch(clearOrderId());&#10;        }&#10;    }, [dispatch]);&#10;&#10;    const [{ isOver }, dropRef] = useDrop(() =&gt; ({&#10;        accept: 'INGREDIENT',&#10;        collect: (monitor) =&gt; ({ isOver: monitor.isOver() }),&#10;        drop: (item: any) =&gt; {&#10;            const uuid = String(Date.now() + Math.random());&#10;            if (item.type === 'bun') {&#10;                dispatch(addIngredient({ ...item, uuid }));&#10;            } else {&#10;                dispatch(addIngredient({ ...item, uuid }));&#10;            }&#10;        }&#10;    }), [dispatch]);&#10;&#10;    const moveItem = useCallback((fromIndex: number, toIndex: number) =&gt; {&#10;        if (fromIndex === toIndex) return;&#10;        dispatch(moveIngredient({ fromIndex, toIndex }));&#10;    }, [dispatch]);&#10;&#10;    // Draggable item component for reordering&#10;    const DraggableConstructorItem: FC&lt;{item: any, index: number}&gt; = ({ item, index }) =&gt; {&#10;        const ref = useRef&lt;HTMLLIElement | null&gt;(null);&#10;        const dispatchLocal = dispatch;&#10;&#10;        const [, drop] = useDrop({&#10;            accept: 'CONSTRUCTOR_ITEM',&#10;            hover(dragged: any, monitor) {&#10;                if (!ref.current) return;&#10;                const dragIndex = dragged.index;&#10;                const hoverIndex = index;&#10;                if (dragIndex === hoverIndex) return;&#10;                const hoverBoundingRect = ref.current.getBoundingClientRect();&#10;                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;&#10;                const clientOffset = monitor.getClientOffset();&#10;                if (!clientOffset) return;&#10;                const hoverClientY = clientOffset.y - hoverBoundingRect.top;&#10;                // only perform the move when the mouse has crossed half of the item's height&#10;                if (dragIndex &lt; hoverIndex &amp;&amp; hoverClientY &lt; hoverMiddleY) return;&#10;                if (dragIndex &gt; hoverIndex &amp;&amp; hoverClientY &gt; hoverMiddleY) return;&#10;                // perform the move&#10;                moveItem(dragIndex, hoverIndex);&#10;                dragged.index = hoverIndex;&#10;            }&#10;        });&#10;&#10;        const [{ isDragging }, drag] = useDrag({&#10;            type: 'CONSTRUCTOR_ITEM',&#10;            item: () =&gt; ({ uuid: item.uuid, index }),&#10;            collect: (monitor) =&gt; ({ isDragging: monitor.isDragging() }),&#10;            canDrag: () =&gt; item.type !== 'bun',&#10;        });&#10;&#10;        drag(drop(ref));&#10;&#10;        return (&#10;            &lt;li ref={ref} className={styles.BurgerConstructorListItem} style={{ opacity: isDragging ? 0.5 : 1 }}&gt;&#10;                &lt;ConstructorElement&#10;                    text={item.name}&#10;                    price={item.price}&#10;                    thumbnail={item.image}&#10;                    handleClose={() =&gt; dispatchLocal(removeIngredient(item.uuid))}&#10;                /&gt;&#10;            &lt;/li&gt;&#10;        );&#10;    };&#10;&#10;    const onSubmitHandler = async (e: SyntheticEvent) =&gt; {&#10;        e.preventDefault();&#10;&#10;        // Собираем список _id для отправки на сервер: bun дважды + остальные ингредиенты&#10;        const ids: string[] = [];&#10;        if (constructorState?.bun) {&#10;            ids.push(constructorState.bun._id, constructorState.bun._id);&#10;        }&#10;        if (constructorState?.items &amp;&amp; constructorState.items.length) {&#10;            ids.push(...constructorState.items.map((it: any) =&gt; it._id));&#10;        }&#10;&#10;        if (ids.length === 0) {&#10;            // ничего не отправляем&#10;            return;&#10;        }&#10;&#10;        try {&#10;            console.debug('Order IDs to send:', ids);&#10;            const orderNumber = await dispatch(createOrder(ids)).unwrap();&#10;            console.debug('createOrder payload (orderNumber):', orderNumber);&#10;            if (orderNumber &amp;&amp; orderNumber &gt; 0) {&#10;                dispatch(setOrderIdAction(String(orderNumber)));&#10;            }&#10;        } catch (err) {&#10;            // thunk rejected — логируем ошибку для отладки&#10;            console.error('Order creation failed', err);&#10;        }&#10;    }&#10;&#10;    const handleRemove = (uuid: string) =&gt; {&#10;        dispatch(removeIngredient(uuid));&#10;    }&#10;&#10;    const totalPrice = useMemo(() =&gt; {&#10;        let sum = 0;&#10;        &#10;        if (constructorState?.bun) sum += constructorState.bun.price * 2;&#10;        if (constructorState?.items?.length) {&#10;            sum += constructorState.items.reduce((acc: number, it: any) =&gt; acc + (it.price || 0), 0);&#10;        }&#10;        return sum;&#10;    }, [constructorState]);&#10;&#10;    return (&#10;        &lt;section&gt;&#10;            &lt;div ref={dropRef as any} className={styles.BurgerConstructor} style={{ background: isOver ? 'transparent' : undefined }}&gt;&#10;                {constructorState?.bun ? (&#10;                    &lt;ConstructorElement&#10;                        type=&quot;top&quot;&#10;                        isLocked={true}&#10;                        text={constructorState.bun.name}&#10;                        price={constructorState.bun.price}&#10;                        thumbnail={constructorState.bun.image}&#10;                    /&gt;&#10;                ) : (&#10;                    &lt;div className={styles.BunPlaceholder + ' text text_type_main-default'}&gt;Перетащите булку сверху&lt;/div&gt;&#10;                )}&#10;                &lt;CustomScrollBar height={464}&gt;&#10;                    &lt;ul className={styles.BurgerConstructorIngredients}&gt;&#10;                        {/* render only added items */}&#10;                        {constructorState?.items?.length ? (&#10;                            constructorState.items.map((it: any, i: number) =&gt; (&#10;                                &lt;DraggableConstructorItem key={it.uuid ?? `${it._id}_${i}`} item={it} index={i} /&gt;&#10;                            ))&#10;                        ) : (&#10;                            &lt;div className={styles.EmptyConstructor + ' text text_type_main-default'}&gt;Перетащите ингредиенты сюда&lt;/div&gt;&#10;                        )}&#10;                    &lt;/ul&gt;&#10;                &lt;/CustomScrollBar&gt;&#10;                {constructorState?.bun ? (&#10;                    &lt;ConstructorElement&#10;                        type=&quot;bottom&quot;&#10;                        isLocked={true}&#10;                        text={constructorState.bun.name}&#10;                        price={constructorState.bun.price}&#10;                        thumbnail={constructorState.bun.image}&#10;                    /&gt;&#10;                ) : (&#10;                    &lt;div className={styles.BunPlaceholder + ' text text_type_main-default'}&gt;Перетащите булку снизу&lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;            &lt;form className={styles.BurgerConstructorForm}&gt;&#10;                &lt;BurgerCredit amount={totalPrice}/&gt;&#10;                &lt;Button htmlType=&quot;button&quot; type=&quot;primary&quot; size=&quot;large&quot; onClick={onSubmitHandler}&gt;&#10;                    Оформить заказ&#10;                &lt;/Button&gt;&#10;            &lt;/form&gt;&#10;        &lt;/section&gt;&#10;    );&#10;};&#10;&#10;export {BurgerConstructor};&#10;" />
              <option name="updatedContent" value="import React, {FC, SyntheticEvent, useEffect, useMemo, useRef, useCallback} from 'react';&#10;import {ConstructorElement, Button} from &quot;@ya.praktikum/react-developer-burger-ui-components&quot;;&#10;import { useDispatch, useSelector } from 'react-redux';&#10;import type { AppDispatch, RootState } from '../../services/store';&#10;import { setOrderId as setOrderIdAction, clearOrderId } from '../../services/orderIdSlice';&#10;import {BurgerCredit} from &quot;../BurgerCredit/BurgerCredit&quot;;&#10;import {CustomScrollBar} from &quot;../CustomScrollBar/CustomScrollBar&quot;;&#10;import { useDrop, useDrag } from 'react-dnd';&#10;import { addIngredient, removeIngredient, moveIngredient } from '../../services/constructorSlice';&#10;import { createOrder } from '../../services/orderSlice';&#10;&#10;import styles from './burger-constructor.module.css';&#10;&#10;const BurgerConstructor: FC = () =&gt; {&#10;    const dispatch = useDispatch&lt;AppDispatch&gt;();&#10;&#10;    const constructorState = useSelector((s: RootState) =&gt; s.burgerConstructor);&#10;&#10;    useEffect(() =&gt; {&#10;        return () =&gt; {&#10;            dispatch(clearOrderId());&#10;        }&#10;    }, [dispatch]);&#10;&#10;    const [{ isOver }, dropRef] = useDrop(() =&gt; ({&#10;        accept: 'INGREDIENT',&#10;        collect: (monitor) =&gt; ({ isOver: monitor.isOver() }),&#10;        drop: (item: any) =&gt; {&#10;            const uuid = String(Date.now() + Math.random());&#10;            if (item.type === 'bun') {&#10;                dispatch(addIngredient({ ...item, uuid }));&#10;            } else {&#10;                dispatch(addIngredient({ ...item, uuid }));&#10;            }&#10;        }&#10;    }), [dispatch]);&#10;&#10;    const moveItem = useCallback((fromIndex: number, toIndex: number) =&gt; {&#10;        if (fromIndex === toIndex) return;&#10;        dispatch(moveIngredient({ fromIndex, toIndex }));&#10;    }, [dispatch]);&#10;&#10;    // Draggable item component for reordering&#10;    const DraggableConstructorItem: FC&lt;{item: any, index: number}&gt; = ({ item, index }) =&gt; {&#10;        const ref = useRef&lt;HTMLLIElement | null&gt;(null);&#10;        const dispatchLocal = dispatch;&#10;&#10;        const [, drop] = useDrop({&#10;            accept: 'CONSTRUCTOR_ITEM',&#10;            hover(dragged: any, monitor) {&#10;                if (!ref.current) return;&#10;                const dragIndex = dragged.index;&#10;                const hoverIndex = index;&#10;                if (dragIndex === hoverIndex) return;&#10;                const hoverBoundingRect = ref.current.getBoundingClientRect();&#10;                const hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;&#10;                const clientOffset = monitor.getClientOffset();&#10;                if (!clientOffset) return;&#10;                const hoverClientY = clientOffset.y - hoverBoundingRect.top;&#10;                // only perform the move when the mouse has crossed half of the item's height&#10;                if (dragIndex &lt; hoverIndex &amp;&amp; hoverClientY &lt; hoverMiddleY) return;&#10;                if (dragIndex &gt; hoverIndex &amp;&amp; hoverClientY &gt; hoverMiddleY) return;&#10;                // perform the move&#10;                moveItem(dragIndex, hoverIndex);&#10;                dragged.index = hoverIndex;&#10;            }&#10;        });&#10;&#10;        const [{ isDragging }, drag] = useDrag({&#10;            type: 'CONSTRUCTOR_ITEM',&#10;            item: () =&gt; ({ uuid: item.uuid, index }),&#10;            collect: (monitor) =&gt; ({ isDragging: monitor.isDragging() }),&#10;            canDrag: () =&gt; item.type !== 'bun',&#10;        });&#10;&#10;        drag(drop(ref));&#10;&#10;        return (&#10;            &lt;li ref={ref} className={styles.BurgerConstructorListItem} style={{ opacity: isDragging ? 0.5 : 1 }}&gt;&#10;                &lt;ConstructorElement&#10;                    text={item.name}&#10;                    price={item.price}&#10;                    thumbnail={item.image}&#10;                    handleClose={() =&gt; dispatchLocal(removeIngredient(item.uuid))}&#10;                /&gt;&#10;            &lt;/li&gt;&#10;        );&#10;    };&#10;&#10;    const onSubmitHandler = async (e: SyntheticEvent) =&gt; {&#10;        e.preventDefault();&#10;&#10;        // Собираем список _id для отправки на сервер: bun дважды + остальные ингредиенты&#10;        const ids: string[] = [];&#10;        if (constructorState?.bun) {&#10;            ids.push(constructorState.bun._id, constructorState.bun._id);&#10;        }&#10;        if (constructorState?.items &amp;&amp; constructorState.items.length) {&#10;            ids.push(...constructorState.items.map((it: any) =&gt; it._id));&#10;        }&#10;&#10;        if (ids.length === 0) {&#10;            // ничего не отправляем&#10;            return;&#10;        }&#10;&#10;        try {&#10;            console.debug('Order IDs to send:', ids);&#10;            const orderNumber = await dispatch(createOrder(ids)).unwrap();&#10;            console.debug('createOrder payload (orderNumber):', orderNumber);&#10;            if (orderNumber &amp;&amp; orderNumber &gt; 0) {&#10;                dispatch(setOrderIdAction(String(orderNumber)));&#10;            }&#10;        } catch (err) {&#10;            // thunk rejected — логируем ошибку для отладки&#10;            console.error('Order creation failed', err);&#10;        }&#10;    }&#10;&#10;    const totalPrice = useMemo(() =&gt; {&#10;        let sum = 0;&#10;        &#10;        if (constructorState?.bun) sum += constructorState.bun.price * 2;&#10;        if (constructorState?.items?.length) {&#10;            sum += constructorState.items.reduce((acc: number, it: any) =&gt; acc + (it.price || 0), 0);&#10;        }&#10;        return sum;&#10;    }, [constructorState]);&#10;&#10;    return (&#10;        &lt;section&gt;&#10;            &lt;div ref={dropRef as any} className={styles.BurgerConstructor} style={{ background: isOver ? 'transparent' : undefined }}&gt;&#10;                {constructorState?.bun ? (&#10;                    &lt;ConstructorElement&#10;                        type=&quot;top&quot;&#10;                        isLocked={true}&#10;                        text={constructorState.bun.name}&#10;                        price={constructorState.bun.price}&#10;                        thumbnail={constructorState.bun.image}&#10;                    /&gt;&#10;                ) : (&#10;                    &lt;div className={styles.BunPlaceholder + ' text text_type_main-default'}&gt;Перетащите булку сверху&lt;/div&gt;&#10;                )}&#10;                &lt;CustomScrollBar height={464}&gt;&#10;                    &lt;ul className={styles.BurgerConstructorIngredients}&gt;&#10;                        {/* render only added items */}&#10;                        {constructorState?.items?.length ? (&#10;                            constructorState.items.map((it: any, i: number) =&gt; (&#10;                                &lt;DraggableConstructorItem key={it.uuid ?? `${it._id}_${i}`} item={it} index={i} /&gt;&#10;                            ))&#10;                        ) : (&#10;                            &lt;div className={styles.EmptyConstructor + ' text text_type_main-default'}&gt;Перетащите ингредиенты сюда&lt;/div&gt;&#10;                        )}&#10;                    &lt;/ul&gt;&#10;                &lt;/CustomScrollBar&gt;&#10;                {constructorState?.bun ? (&#10;                    &lt;ConstructorElement&#10;                        type=&quot;bottom&quot;&#10;                        isLocked={true}&#10;                        text={constructorState.bun.name}&#10;                        price={constructorState.bun.price}&#10;                        thumbnail={constructorState.bun.image}&#10;                    /&gt;&#10;                ) : (&#10;                    &lt;div className={styles.BunPlaceholder + ' text text_type_main-default'}&gt;Перетащите булку снизу&lt;/div&gt;&#10;                )}&#10;            &lt;/div&gt;&#10;            &lt;form className={styles.BurgerConstructorForm}&gt;&#10;                &lt;BurgerCredit amount={totalPrice}/&gt;&#10;                &lt;Button htmlType=&quot;button&quot; type=&quot;primary&quot; size=&quot;large&quot; onClick={onSubmitHandler}&gt;&#10;                    Оформить заказ&#10;                &lt;/Button&gt;&#10;            &lt;/form&gt;&#10;        &lt;/section&gt;&#10;    );&#10;};&#10;&#10;export {BurgerConstructor};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>